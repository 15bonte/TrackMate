package fiji.plugin.trackmate;

import java.util.ArrayList;
import java.util.EnumMap;
import java.util.List;
import java.util.TreeMap;

import org.jgrapht.graph.DefaultEdge;
import org.jgrapht.graph.SimpleWeightedGraph;

import fiji.plugin.trackmate.features.FeatureFacade;
import fiji.plugin.trackmate.segmentation.SpotSegmenter;

/**
 * This is the interface for the models behind TrackMate. A model should be able to back-up
 * a GUI, and completely pilot and execute a segmentation + tracking process.
 * 
 * @author Jean-Yves Tinevez <jeanyves.tinevez@gmail.com> - Jan 1, 2011
 */
public interface TrackMateModelInterface {


	/*
	 * SPOTS
	 */
	
	/**
	 * Overwrite the {@link #spots} field, resulting from segmentation.
	 */
	public void setSpots(TreeMap<Integer, List<Spot>> spots);

	/**
	 * Return the spots generated by the segmentation part of this plugin. The collection are un-filtered and contain
	 * all spots. They are returned as a List of Collection, one item in the list per time-point, in order.
	 */
	public TreeMap<Integer, List<Spot>> getSpots();

	/*
	 * SPOT SELECTION
	 */
	
	/**
	 * Overwrite the {@link #selectedSpots} field, resulting (normally) from feature thresholding.
	 */
	public void setSpotSelection(TreeMap<Integer, List<Spot>> selectedSpots);

	/**
	 * Return the spots filtered by feature threshold. Feature thresholds can be set / added / cleared by 
	 * {@link #setFeatureThresholds(List)}, {@link #addThreshold(FeatureThreshold)} and {@link #clearTresholds()}.
	 */
	public TreeMap<Integer, List<Spot>> getSelectedSpots();

	/*
	 * SETTINGS
	 */
	
	/**
	 * Return the {@link Settings} object that determines the behavior of this plugin.
	 */
	public Settings getSettings();

	/**
	 * Set the {@link Settings} object that determines the behavior of this plugin.
	 */
	public void setSettings(Settings settings);
	
	/*
	 * TRACKS
	 */

	public SimpleWeightedGraph<Spot, DefaultEdge> getTrackGraph();

	/**
	 * Overwrite the {@link #trackGraph} field, resulting from the tracking step.
	 */
	public void setTrackGraph(SimpleWeightedGraph<Spot, DefaultEdge> trackGraph);

	/*
	 * LOGGER
	 */
	
	/**
	 * Set the logger that will receive the messages from the processes occurring within this plugin.
	 */
	public void setLogger(Logger logger);

	
	/*
	 * FEATURE THRESHOLDS AND VALUES
	 */
	
	/**
	 * Return the initial threshold on {@link Feature#QUALITY} stored in this model.
	 */
	public Float getInitialThreshold();

	/**
	 * Set the initial threshold on {@link Feature#QUALITY} stored in this model.
	 */
	public void setInitialThreshold(Float initialThreshold);

	
	public List<FeatureThreshold> getFeatureThresholds();

	public void setFeatureThresholds(List<FeatureThreshold> thresholds);

	/**
	 * Add a threshold to the list of thresholds to deal with when executing {@link #execThresholding(List, ArrayList, ArrayList, ArrayList)}.
	 */
	public void addThreshold(FeatureThreshold threshold);

	public void removeThreshold(FeatureThreshold threshold);

	public void clearTresholds();

	/**
	 * Return a map of {@link Feature} values for the spot collection held by this instance.
	 * Each feature maps a double array, with 1 element per {@link Spot}, all pooled
	 * together.
	 */
	public EnumMap<Feature, double[]> getFeatureValues();

	/*
	 * PROCESSES
	 */
	
	/** 
	 * Execute the segmentation part.
	 * <p>
	 * This method looks for bright blobs: bright object of approximately spherical shape, whose expected 
	 * diameter is given in argument. The method used for segmentation depends on the {@link SpotSegmenter} 
	 * chosen, and set in {@link #settings};
	 * <p>
	 * This gives us a collection of spots, which at this stage simply wrap a physical center location. 
	 * @see #getSpots()
	 */
	public void execSegmentation();

	/**
	 * Calculate features for all segmented spots.
	 * <p>
	 * Features are calculated for each spot, using their location, and the raw image. See the {@link FeatureFacade} class
	 * for details. 
	 */
	public void computeFeatures();

	/**
	 * Execute the tracking part.
	 * <p>
	 * This method links all the selected spots from the thresholding part using the selected tracking algorithm.
	 * This tracking process will generate a graph (more precisely a {@link SimpleWeightedGraph}) made of the spot 
	 * election for its vertices, and edges representing the links.
	 * @see #getTrackGraph()
	 */ 
	public void execTracking();

	/**
	 * Execute the initial thresholding part.
	 *<p>
	 * Because of the presence of noise, it is possible that some of the regional maxima found in the segmenting step have
	 * identified noise, rather than objects of interest. This can generates a very high number of spots, which is
	 * inconvenient to deal with when it comes to  computing their features, or displaying them.
	 * <p>
	 * Any {@link SpotSegmenter} is expected to at least compute the {@link Feature#QUALITY} value for each spot
	 * it creates, so it is possible to set up an initial thresholding on this Feature, prior to any other operation. 
	 * <p>
	 * This method simply takes all the segmented spots, and discard those whose quality value is below the threshold set 
	 * by {@link #setInitialThreshold(Float)}. The spot field is overwritten, and discarded spots can't be recalled.
	 * 
	 * @see #getSpots()
	 * @see #setInitialThreshold(Float)
	 */
	public void execInitialThresholding();
	
	/**
	 * Execute the feature thresholding part.
	 *<p>
	 * Because of the presence of noise, it is possible that some of the regional maxima found in the segmenting step have
	 * identified noise, rather than objects of interest. A thresholding operation based on the calculated features in this
	 * step should allow to rule them out.
	 * <p>
	 * This method simply takes all the segmented spots, and store in the field {@link #selectedSpots}
	 * the spots whose features satisfy all of the thresholds entered with the method {@link #addThreshold(FeatureThreshold)}
	 * @see #getSelectedSpots()
	 */
	public void execThresholding();


}
