package fiji.plugin.trackmate;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.jgrapht.graph.DefaultWeightedEdge;
import org.jgrapht.graph.SimpleDirectedWeightedGraph;
import org.jgrapht.traverse.DepthFirstIterator;

import fiji.plugin.trackmate.features.FeatureModel;
import fiji.plugin.trackmate.visualization.TrackMateModelView;

/**
 * <h1>The model for the data managed by TrackMate plugin.</h1>
 * <p>
 * This is a relatively large class, with a lot of public methods. This
 * complexity arose because this class handles data storage and manipulation,
 * through user manual editing and automatic processing. To avoid conflicting
 * accesses to the data, some specialized methods had to be created, hopefully
 * built in coherent sets.
 * 
 * <h2>Main data stored in this model</h2>
 * 
 * We only list here the central fields. This model has other fields, but they
 * are derived from these following 6 fields or used to modify them. These are
 * the only 6 fields that should be written to a file, and they should be enough
 * to fully reconstruct a new model. By processing order, this model stores the
 * following data.
 * 
 * <h3> {@link #settings}</h3>
 * 
 * The {@link Settings} object that determines the behavior of processes,
 * generating the data stored by this model.
 * 
 * <h3>{@link #spots}</h3>
 * 
 * The raw spots generated by the detection process, stored as
 * {@link SpotCollection}.
 * 
 * <h3>{@link #initialSpotFilterValue}</h3>
 * 
 * The value of the initial Spot {@link FeatureFilter} on
 * {@link SpotFeature#QUALITY}. Since this filter is constrained to be on
 * quality, and above threshold, we do not store the filter itself (preventing
 * some nasty modifications to be possible), but simply the value of the
 * threshold. That filter will be used to crop the {@link #spots} field: spots
 * with quality lower than this threshold will be removed from the
 * {@link SpotCollection}. They will not be stored, nor saved, nor displayed and
 * their features will not be calculated. This is intended to save computation
 * time only.
 * 
 * <h3>{@link #spotFilters}</h3>
 * 
 * The list of Spot {@link FeatureFilter} that the user can set on any computed
 * feature. It will be used to filter spots and generate the
 * {@link #spotSelection} field, that will be used for tracking.
 * <p>
 * Since it only serves to determine the effect of a process (filtering spots by
 * feature), it logically could be a sub-field of the {@link #settings} object.
 * We found more convenient to have it attached to the model.
 * 
 * <h3>{@link #spotSelection}</h3>
 * 
 * The filtered spot, as a new {@link SpotCollection}. It is important that this
 * collection is made with the same spot objects than for the {@link #spots} field.
 * 
 * <h3>{@link #graph}</h3>
 * 
 * The {@link SimpleDirectedWeightedGraph} that contains the map of links between spots.
 * The vertices of the graph are the content of the {@link #spotSelection}
 * field. This is the only convenient way to store links in their more general
 * way we have thought of.
 * <p>
 * It is an undirected graph: we do not indicate the time forward direction
 * using edge direction, but simply refer to the per-frame organization of the
 * {@link SpotCollection}.
 * 
 * <h3>{@link #filteredTrackKeys}</h3>
 * 
 * This Set contains the index of the tracks that are set to be visible. We use this 
 * to flag the tracks that should be retained after filtering the tracks by their
 * features, for instance. Because the user can edit this manually, or because 
 * the track visibility can changed when merging 2 track manually (for instance),
 * we stress on the 'visibility' meaning of this field. 
 * <p>
 * The set contains the indices of the tracks that are visible, in the List
 * of {@link #trackEdges} and {@link #trackSpots}, that are described below.
 * These fields are generated automatically from the track {@link #graph}.
 * For instance, if this set is made of [2, 4], that means the tracks with
 * the indices 2 and 4 in the aforementioned lists are visible, the other not.
 * Of course, {@link TrackMateModelView}s are expected to acknowledge this 
 * content. 
 * <p>
 * This field can be modified publicly using the  {@link #setTrackVisible(Integer, boolean, boolean)}
 * method, or totally overwritten using the {@link #setFilteredTrackIDs(Set, boolean)} method.
 * However, some modifications can arise coming from manual editing of tracks. For instance
 * removing an edge from the middle of a visible tracks generates two new tracks, and
 * possibly shifts the indices of the other tracks. This is hopefully taken care of 
 * the model internal work, and the following rules are implements:
 * <ul>
 * 	<li> TODO
 * </ul>   
 * 
 * <h2>Dependent data</h2>
 * 
 * We list here the fields whose value depends on 
 * 
 * @author Jean-Yves Tinevez <tinevez@pasteur.fr> - 2010-2011
 * 
 */
public class TrackMateModel {

	/*
	 * CONSTANTS
	 */

	private static final boolean DEBUG = false;
	private static final boolean DEBUG_SELECTION = false;

	/*
	 * FIELDS
	 */

	// FEATURES

	private final FeatureModel featureModel;
	
	// TRACKS
	
	private final TrackGraphModel trackGraphModel;

	// SPOTS

	/** Contain the detection result, un-filtered. */
	protected SpotCollection spots = new SpotCollection();
	/** Contain the spots retained for tracking, after filtering by features. */
	protected SpotCollection filteredSpots = new SpotCollection();


	// TRANSACTION MODEL

	/**
	 * Counter for the depth of nested transactions. Each call to beginUpdate
	 * increments this counter and each call to endUpdate decrements it. When
	 * the counter reaches 0, the transaction is closed and the respective
	 * events are fired. Initial value is 0.
	 */
	private int updateLevel = 0;
	private List<Spot> spotsAdded = new ArrayList<Spot>();
	private List<Spot> spotsRemoved = new ArrayList<Spot>();
	private List<Spot> spotsMoved = new ArrayList<Spot>();
	private List<Spot> spotsUpdated = new ArrayList<Spot>();
	/**
	 * The event cache. During a transaction, some modifications might trigger
	 * the need to fire a model change event. We want to fire these events only
	 * when the transaction closes (when the updayeLevel reaches 0), so we store
	 * the event ID in this cache in the meantime. The event cache contains only
	 * the int IDs of the events listed in {@link TrackMateModelChangeEvent},
	 * namely
	 * <ul>
	 * <li> {@link TrackMateModelChangeEvent#SPOTS_COMPUTED}
	 * <li> {@link TrackMateModelChangeEvent#SPOT_FILTERED}
	 * <li> {@link TrackMateModelChangeEvent#TRACKS_COMPUTED}
	 * <li> {@link TrackMateModelChangeEvent#TRACKS_VISIBILITY_CHANGED}
	 * </ul>
	 * The {@link TrackMateModelChangeEvent#MODEL_MODIFIED} cannot be cached
	 * this way, for it needs to be configured with modification spot and edge
	 * targets, so it uses a different system (see {@link #flushUpdate()}).
	 */
	private HashSet<Integer> eventCache = new HashSet<Integer>();

	// SELECTION

	/** The spot current selection. */
	private Set<Spot> spotSelection = new HashSet<Spot>();
	/** The edge current selection. */
	Set<DefaultWeightedEdge> edgeSelection = new HashSet<DefaultWeightedEdge>();

	// OTHERS

	/** The logger to append processes messages */
	private Logger logger = Logger.DEFAULT_LOGGER;
	/** The settings that determine processes actions */
	private Settings settings = new Settings();

	// LISTENERS

	/**
	 * The list of listeners listening to model content change, that is, changes
	 * in {@link #spots}, {@link #filteredSpots} and {@link #trackGraph}.
	 */
	List<TrackMateModelChangeListener> modelChangeListeners = new ArrayList<TrackMateModelChangeListener>();
	/** The list of listener listening to change in selection. */
	List<TrackMateSelectionChangeListener> selectionChangeListeners = new ArrayList<TrackMateSelectionChangeListener>();
	

	




	/*
	 * CONSTRUCTOR
	 */

	public TrackMateModel() {
		featureModel = new FeatureModel(this);
		trackGraphModel = new TrackGraphModel(this);
	}


	/*
	 * UTILS METHODS
	 */

	@Override
	public String toString() {
		StringBuilder str = new StringBuilder();

		str.append(settings);

		str.append('\n');
		if (null == spots || spots.size() == 0) {
			str.append("No spots.\n");
		} else {
			str.append("Contains " + spots.getNSpots() + " spots in total.\n");
		}
		if (null == spots || spots.size() == 0) {
			str.append("No filtered spots.\n");
		} else {
			str.append("Contains " + filteredSpots.getNSpots() + " filtered spots.\n");
		}
		
		str.append('\n');
		if (trackGraphModel.getNTracks() == 0) {
			str.append("No tracks.\n");
		} else {
			str.append("Contains " + trackGraphModel.getNTracks() + " tracks in total.\n");
		}
		if (trackGraphModel.getNFilteredTracks() == 0) {
			str.append("No filtered tracks.\n");
		} else {
			str.append("Contains " + trackGraphModel.getNFilteredTracks() + " filtered tracks.\n");
		}
		
		return str.toString();
	}



	/*
	 * DEAL WITH MODEL CHANGE LISTENER
	 */

	public void addTrackMateModelChangeListener(TrackMateModelChangeListener listener) {
		modelChangeListeners.add(listener);
	}

	public boolean removeTrackMateModelChangeListener(TrackMateModelChangeListener listener) {
		return modelChangeListeners.remove(listener);
	}

	public List<TrackMateModelChangeListener> getTrackMateModelChangeListener(TrackMateModelChangeListener listener) {
		return modelChangeListeners;
	}

	/*
	 * DEAL WITH SELECTION CHANGE LISTENER
	 */

	public void addTrackMateSelectionChangeListener(TrackMateSelectionChangeListener listener) {
		selectionChangeListeners.add(listener);
	}

	public boolean removeTrackMateSelectionChangeListener(TrackMateSelectionChangeListener listener) {
		return selectionChangeListeners.remove(listener);
	}

	public List<TrackMateSelectionChangeListener> getTrackMateSelectionChangeListener() {
		return selectionChangeListeners;
	}


	/*
	 * GRAPH MODIFICATION
	 */

	public void beginUpdate() {
		updateLevel++;
		if (DEBUG)
			System.out.println("[TrackMateModel] #beginUpdate: increasing update level to " + updateLevel + ".");
	}

	public void endUpdate() {
		updateLevel--;
		if (DEBUG)
			System.out.println("[TrackMateModel] #endUpdate: decreasing update level to " + updateLevel + ".");
		if (updateLevel == 0) {
			if (DEBUG)
				System.out.println("[TrackMateModel] #endUpdate: update level is 0, calling flushUpdate().");
			flushUpdate();
		}
	}

	/*
	 * TRACK METHODS: WE DELEGATE TO THE TRACK GRAPH MODEL
	 */
	

	/** @see TrackGraphModel#trackToString(Integer) */
	public String trackToString(Integer trackID) {
		return trackGraphModel.trackToString(trackID);
	}

	/** @see TrackGraphModel#addEdge(Spot, Spot, double) */
	public DefaultWeightedEdge addEdge(Spot source, Spot target, int weight) {
		return trackGraphModel.addEdge(source, target, weight);
	}

	/** @see TrackGraphModel#removeEdge(DefaultWeightedEdge) */
	public void removeEdge(DefaultWeightedEdge edge) {
		trackGraphModel.removeEdge(edge);
	}

	/** @see TrackGraphModel#getEdge(Spot, Spot) */
	public DefaultWeightedEdge getEdge(Spot source, Spot target) {
		return trackGraphModel.getEdge(source, target);
	}

	/** @see TrackGraphModel#edgesOf(Spot) */
	public Set<DefaultWeightedEdge> edgesOf(Spot spot) {
		return trackGraphModel.edgesOf(spot);
	}
	
	/** @see TrackGraphModel#getEdgeSource(DefaultWeightedEdge) */
	public Spot getEdgeSource(DefaultWeightedEdge edge) {
		return trackGraphModel.getEdgeSource(edge);
	}

	/** @see TrackGraphModel#getEdgeTarget(DefaultWeightedEdge) */
	public Spot getEdgeTarget(DefaultWeightedEdge edge) {
		return trackGraphModel.getEdgeTarget(edge);
	}
	
	/** @see TrackGraphModel#getEdgeWeight(DefaultWeightedEdge) */
	public double getEdgeWeight(DefaultWeightedEdge edge) {
		return trackGraphModel.getEdgeWeight(edge);
	}
	
	/** @see TrackGraphModel#containsEdge(Spot, Spot) */
	public boolean containsEdge(Spot source, Spot target) {
		return trackGraphModel.containsEdge(source, target);
	}
	
	/** @see TrackGraphModel#dijkstraShortestPath(Spot, Spot) */
	public List<DefaultWeightedEdge> dijkstraShortestPath(Spot start, Spot end) {
		return trackGraphModel.dijkstraShortestPath(start, end);
	}
	
	/** @see TrackGraphModel#getDepthFirstIterator(Spot) */
	public DepthFirstIterator<Spot, DefaultWeightedEdge> getDepthFirstIterator(Spot start) {
		return trackGraphModel.getDepthFirstIterator(start);
	}
	
	/** @see TrackGraphModel#getUndirectedDepthFirstIterator(Spot) */
	public DepthFirstIterator<Spot, DefaultWeightedEdge> getUndirectedDepthFirstIterator(Spot start) {
		return trackGraphModel.getUndirectedDepthFirstIterator(start);
	}
	
	/** @see TrackGraphModel#getTrackSpots() */
	public Map<Integer, Set<Spot>> getTrackSpots() {
		return trackGraphModel.getTrackSpots();
	}
		
	/** @see TrackGraphModel#getTrackSpots(Integer) */
	public Set<Spot> getTrackSpots(Integer trackID) {
		return trackGraphModel.getTrackSpots(trackID);
	}
	
	/** @see TrackGraphModel#getTrackEdges() */
	public Map<Integer, Set<DefaultWeightedEdge>> getTrackEdges() {
		return trackGraphModel.getTrackEdges();
	}
	
	/** @see TrackGraphModel#getTrackEdges(Integer) */
	public Set<DefaultWeightedEdge> getTrackEdges(Integer trackID) {
		return trackGraphModel.getTrackEdges(trackID);
	}


	/** @see TrackGraphModel#setGraph(SimpleDirectedWeightedGraph) */
	public void setGraph(SimpleDirectedWeightedGraph<Spot, DefaultWeightedEdge> graph) {
		trackGraphModel.setGraph(graph);
	}

	/** @see TrackGraphModel#getTrackIDs()	 */
	public Collection<Integer> getTrackIDs() {
		return trackGraphModel.getTrackIDs();
	}
	
	/** @see TrackGraphModel#getTrackIDOf(Spot) */
	public Integer getTrackIDOf(Spot spot) {
		return trackGraphModel.getTrackIDOf(spot);
	}

	/** @see TrackGraphModel#getTrackIDOf(DefaultWeightedEdge) */
	public Integer getTrackIDOf(DefaultWeightedEdge edge) {
		return trackGraphModel.getTrackIDOf(edge);
	}
	
	/** @see TrackGraphModel#getFilteredTrackIDs() */
	public Set<Integer> getFilteredTrackIDs() {
		return trackGraphModel.getFilteredTrackIDs();
	}
	
	/** @see TrackGraphModel#setFilteredTrackIDs(Set, boolean) */
	public void setFilteredTrackIDs(Set<Integer> filteredTrackIndices, boolean doNotify) {
		trackGraphModel.setFilteredTrackIDs(filteredTrackIndices, doNotify);
	}
	
	/** @see TrackGraphModel#setFilteredTrackID(Integer, boolean, boolean) */
	public boolean setFilteredTrackID(Integer trackID, boolean filtered, boolean doNotify) {
		return trackGraphModel.setFilteredTrackID(trackID, filtered, doNotify);
	}

	/** @see TrackGraphModel#isTrackFiltered(int) */
	public boolean isTrackFiltered(Integer trackID) {
		return trackGraphModel.isTrackFiltered(trackID);
	}

	/** @see TrackGraphModel#getNTracks() */
	public int getNTracks() {
		return trackGraphModel.getNTracks();
	}
	
	/** @see TrackGraphModel#getNFilteredTracks() */
	public int getNFilteredTracks() {
		return trackGraphModel.getNFilteredTracks();
	}

	/** @see TrackGraphModel#edgeSet()	 */
	public Collection<DefaultWeightedEdge> edgeSet() {
		return trackGraphModel.edgeSet();
	}
	
	
	
	
	/*
	 * GETTERS / SETTERS FOR SPOTS
	 */


	/**
	 * @return the spots generated by the detection part of this plugin. The
	 * collection are un-filtered and contain all spots. They are returned as a
	 * {@link SpotCollection}.
	 */
	public SpotCollection getSpots() {
		return spots;
	}

	/**
	 * Return the spots filtered by feature filters. These spots will be used
	 * for subsequent tracking and display.
	 * <p>
	 * Feature thresholds can be set / added / cleared by
	 * {@link #setSpotFilters(List)}, {@link #addSpotFilter(SpotFilter)} and
	 * {@link #clearSpotFilters()}.
	 */
	public SpotCollection getFilteredSpots() {
		return filteredSpots;
	}

	/**
	 * Overwrite the raw {@link #spots} field, resulting normally from the
	 * {@link #execDetection()} process.
	 * 
	 * @param spots
	 * @param doNotify
	 *            if true, will file a
	 *            {@link TrackMateModelChangeEvent#SPOTS_COMPUTED} event.
	 */
	public void setSpots(SpotCollection spots, boolean doNotify) {
		this.spots = spots;
		if (doNotify) {
			final TrackMateModelChangeEvent event = new TrackMateModelChangeEvent(this, TrackMateModelChangeEvent.SPOTS_COMPUTED);
			for (TrackMateModelChangeListener listener : modelChangeListeners)
				listener.modelChanged(event);
		}
	}

	/**
	 * Overwrite the {@link #filteredSpots} field, resulting normally from the
	 * {@link #execSpotFiltering()} process.
	 * 
	 * @param doNotify  if true, will fire a {@link TrackMateModelChangeEvent#SPOTS_FILTERED} event.
	 */
	public void setFilteredSpots(final SpotCollection filteredSpots, boolean doNotify) {
		this.filteredSpots = filteredSpots;
		if (doNotify) {
			final TrackMateModelChangeEvent event = new TrackMateModelChangeEvent(this, TrackMateModelChangeEvent.SPOTS_FILTERED);
			for (TrackMateModelChangeListener listener : modelChangeListeners)
				listener.modelChanged(event);
		}
	}

	/*
	 * LOGGER
	 */

	/**
	 * Set the logger that will receive the messages from the processes
	 * occurring within this plugin.
	 */
	public void setLogger(Logger logger) {
		this.logger = logger;
	}

	/**
	 * Return the logger currently set for this model.
	 */
	public Logger getLogger() {
		return logger;
	}

	/*
	 * SETTINGS
	 */

	/**
	 * Return the {@link Settings} object that determines the behavior of this plugin.
	 */
	public Settings getSettings() {
		return settings;
	}

	/**
	 * Set the {@link Settings} object that determines the behavior of this
	 * model's processes.
	 * 
	 * @see #execDetection()
	 * @see #execTracking()
	 */

	public void setSettings(Settings settings) {
		this.settings = settings;
	}

	/*
	 * FEATURES
	 */

	public FeatureModel getFeatureModel() {
		return featureModel;
	}

	/*
	 * SELECTION METHODSs
	 */

	public void clearSelection() {
		if (DEBUG_SELECTION)
			System.out.println("[TrackMateModel] Clearing selection");
		// Prepare event
		Map<Spot, Boolean> spotMap = new HashMap<Spot, Boolean>(spotSelection.size());
		for (Spot spot : spotSelection)
			spotMap.put(spot, false);
		Map<DefaultWeightedEdge, Boolean> edgeMap = new HashMap<DefaultWeightedEdge, Boolean>(edgeSelection.size());
		for (DefaultWeightedEdge edge : edgeSelection)
			edgeMap.put(edge, false);
		TrackMateSelectionChangeEvent event = new TrackMateSelectionChangeEvent(this, spotMap, edgeMap);
		// Clear fields
		clearSpotSelection();
		clearEdgeSelection();
		// Fire event
		for (TrackMateSelectionChangeListener listener : selectionChangeListeners)
			listener.selectionChanged(event);
	}

	public void clearSpotSelection() {
		if (DEBUG_SELECTION)
			System.out.println("[TrackMateModel] Clearing spot selection");
		// Prepare event
		Map<Spot, Boolean> spotMap = new HashMap<Spot, Boolean>(spotSelection.size());
		for (Spot spot : spotSelection)
			spotMap.put(spot, false);
		TrackMateSelectionChangeEvent event = new TrackMateSelectionChangeEvent(this, spotMap, null);
		// Clear field
		spotSelection.clear();
		// Fire event
		for (TrackMateSelectionChangeListener listener : selectionChangeListeners)
			listener.selectionChanged(event);
	}

	public void clearEdgeSelection() {
		if (DEBUG_SELECTION)
			System.out.println("[TrackMateModel] Clearing edge selection");
		// Prepare event
		Map<DefaultWeightedEdge, Boolean> edgeMap = new HashMap<DefaultWeightedEdge, Boolean>(edgeSelection.size());
		for (DefaultWeightedEdge edge : edgeSelection)
			edgeMap.put(edge, false);
		TrackMateSelectionChangeEvent event = new TrackMateSelectionChangeEvent(this, null, edgeMap);
		// Clear field
		edgeSelection.clear();
		// Fire event
		for (TrackMateSelectionChangeListener listener : selectionChangeListeners)
			listener.selectionChanged(event);
	}

	public void addSpotToSelection(final Spot spot) {
		if (!spotSelection.add(spot))
			return; // Do nothing if already present in selection
		if (DEBUG_SELECTION)
			System.out.println("[TrackMateModel] Adding spot " + spot + " to selection");
		Map<Spot, Boolean> spotMap = new HashMap<Spot, Boolean>(1);
		spotMap.put(spot, true);
		if (DEBUG_SELECTION)
			System.out.println("[TrackMateModel] Seding event to listeners: "+selectionChangeListeners);
		TrackMateSelectionChangeEvent event = new TrackMateSelectionChangeEvent(this, spotMap, null);
		for (TrackMateSelectionChangeListener listener : selectionChangeListeners)
			listener.selectionChanged(event);
	}

	public void removeSpotFromSelection(final Spot spot) {
		if (!spotSelection.remove(spot))
			return; // Do nothing was not already present in selection
		if (DEBUG_SELECTION)
			System.out.println("[TrackMateModel] Removing spot " + spot + " from selection");
		Map<Spot, Boolean> spotMap = new HashMap<Spot, Boolean>(1);
		spotMap.put(spot, false);
		TrackMateSelectionChangeEvent event = new TrackMateSelectionChangeEvent(this, spotMap, null);
		for (TrackMateSelectionChangeListener listener : selectionChangeListeners)
			listener.selectionChanged(event);
	}

	public void addSpotToSelection(final Collection<Spot> spots) {
		Map<Spot, Boolean> spotMap = new HashMap<Spot, Boolean>(spots.size());
		for (Spot spot : spots) {
			if (spotSelection.add(spot)) {
				spotMap.put(spot, true);
				if (DEBUG_SELECTION)
					System.out.println("[TrackMateModel] Adding spot " + spot + " to selection");
			}
		}
		TrackMateSelectionChangeEvent event = new TrackMateSelectionChangeEvent(this, spotMap, null);
		if (DEBUG_SELECTION) 
			System.out.println("[TrackMateModel] Seding event "+event.hashCode()+" to "+selectionChangeListeners.size()+" listeners: "+selectionChangeListeners);
		for (TrackMateSelectionChangeListener listener : selectionChangeListeners)
			listener.selectionChanged(event);
	}

	public void removeSpotFromSelection(final Collection<Spot> spots) {
		Map<Spot, Boolean> spotMap = new HashMap<Spot, Boolean>(spots.size());
		for (Spot spot : spots) {
			if (spotSelection.remove(spot)) {
				spotMap.put(spot, false);
				if (DEBUG_SELECTION)
					System.out.println("[TrackMateModel] Removing spot " + spot + " from selection");
			}
		}
		TrackMateSelectionChangeEvent event = new TrackMateSelectionChangeEvent(this, spotMap, null);
		for (TrackMateSelectionChangeListener listener : selectionChangeListeners)
			listener.selectionChanged(event);
	}

	public void addEdgeToSelection(final DefaultWeightedEdge edge) {
		if (!edgeSelection.add(edge))
			return; // Do nothing if already present in selection
		if (DEBUG_SELECTION)
			System.out.println("[TrackMateModel] Adding edge " + edge + " to selection");
		Map<DefaultWeightedEdge, Boolean> edgeMap = new HashMap<DefaultWeightedEdge, Boolean>(1);
		edgeMap.put(edge, true);
		TrackMateSelectionChangeEvent event = new TrackMateSelectionChangeEvent(this, null, edgeMap);
		for (TrackMateSelectionChangeListener listener : selectionChangeListeners)
			listener.selectionChanged(event);

	}

	public void removeEdgeFromSelection(final DefaultWeightedEdge edge) {
		if (!edgeSelection.remove(edge))
			return; // Do nothing if already present in selection
		if (DEBUG_SELECTION)
			System.out.println("[TrackMateModel] Removing edge " + edge + " from selection");
		Map<DefaultWeightedEdge, Boolean> edgeMap = new HashMap<DefaultWeightedEdge, Boolean>(1);
		edgeMap.put(edge, false);
		TrackMateSelectionChangeEvent event = new TrackMateSelectionChangeEvent(this, null, edgeMap);
		for (TrackMateSelectionChangeListener listener : selectionChangeListeners)
			listener.selectionChanged(event);

	}

	public void addEdgeToSelection(final Collection<DefaultWeightedEdge> edges) {
		Map<DefaultWeightedEdge, Boolean> edgeMap = new HashMap<DefaultWeightedEdge, Boolean>(edges.size());
		for (DefaultWeightedEdge edge : edges) {
			if (edgeSelection.add(edge)) {
				edgeMap.put(edge, true);
				if (DEBUG_SELECTION)
					System.out.println("[TrackMateModel] Adding edge " + edge + " to selection");
			}
		}
		TrackMateSelectionChangeEvent event = new TrackMateSelectionChangeEvent(this, null, edgeMap);
		for (TrackMateSelectionChangeListener listener : selectionChangeListeners)
			listener.selectionChanged(event);
	}

	public void removeEdgeFromSelection(final Collection<DefaultWeightedEdge> edges) {
		Map<DefaultWeightedEdge, Boolean> edgeMap = new HashMap<DefaultWeightedEdge, Boolean>(edges.size());
		for (DefaultWeightedEdge edge : edges) {
			if (edgeSelection.remove(edge)) {
				edgeMap.put(edge, false);
				if (DEBUG_SELECTION)
					System.out.println("[TrackMateModel] Removing edge " + edge + " from selection");
			}
		}
		TrackMateSelectionChangeEvent event = new TrackMateSelectionChangeEvent(this, null, edgeMap);
		for (TrackMateSelectionChangeListener listener : selectionChangeListeners)
			listener.selectionChanged(event);
	}

	public Set<Spot> getSpotSelection() {
		return spotSelection;
	}

	public Set<DefaultWeightedEdge> getEdgeSelection() {
		return edgeSelection;
	}

	/*
	 * MODEL CHANGE METHODS
	 */

	/**
	 * Move a single spot from a frame to another, then update its features.
	 * 
	 * @param spotToMove  the spot to move
	 * @param fromFrame  the frame the spot originated from
	 * @param toFrame  the destination frame
	 * @param doNotify   if false, {@link TrackMateModelChangeListener}s will not be
	 * notified of this change
	 */
	public void moveSpotFrom(Spot spotToMove, Integer fromFrame, Integer toFrame) {
		spots.add(spotToMove, toFrame);
		spots.remove(spotToMove, fromFrame);
		if (DEBUG)
			System.out.println("[TrackMateModel] Moving " + spotToMove + " from frame " + fromFrame + " to frame " + toFrame);

		filteredSpots.add(spotToMove, toFrame);
		filteredSpots.remove(spotToMove, fromFrame);

		spotsMoved.add(spotToMove); // TRANSACTION

	}

	/**
	 * Add a single spot to the collections managed by this model, then update
	 * its features.
	 */
	public void addSpotTo(Spot spotToAdd, Integer toFrame) {
		if (spots.add(spotToAdd, toFrame)) {
			spotsAdded.add(spotToAdd); // TRANSACTION
			if (DEBUG)
				System.out.println("[TrackMateModel] Adding spot " + spotToAdd + " to frame " + toFrame);
		}
		filteredSpots.add(spotToAdd, toFrame);
		trackGraphModel.addSpot(spotToAdd);

	}

	/**
	 * Remove a single spot from the collections managed by this model.
	 * 
	 * @param fromFrame
	 *            the frame the spot is in, if it is known. If <code>null</code>
	 *            is given, then the adequate frame is retrieved from this
	 *            model's collections.
	 */
	public void removeSpotFrom(final Spot spotToRemove, Integer fromFrame) {
		if (fromFrame == null)
			fromFrame = spots.getFrame(spotToRemove);
		if (spots.remove(spotToRemove, fromFrame)) {
			spotsRemoved.add(spotToRemove); // TRANSACTION
			if (DEBUG)
				System.out.println("[TrackMateModel] Removing spot " + spotToRemove + " from frame " + fromFrame);
		}
		filteredSpots.remove(spotToRemove, fromFrame);
		spotSelection.remove(spotToRemove);
		trackGraphModel.removeSpot(spotToRemove);
	}

	/*
	 * MODIFY SPOT FEATURES
	 */

	/**
	 * Do the actual feature update for given spots.
	 */
	private void updateFeatures(final List<Spot> spotsToUpdate) {
		if (DEBUG)
			System.out.println("[TrackMateModel] Updating the features of " + spotsToUpdate.size() + " spots.");

		// Find common frames
		SpotCollection toCompute = filteredSpots.subset(spotsToUpdate);
		featureModel.computeSpotFeatures(toCompute);
	}

	public void updateFeatures(final Spot spotToUpdate) {
		spotsUpdated.add(spotToUpdate); // Enlist for feature update when transaction is marked as finished
	}


	/*
	 * PRIVATE METHODS
	 */


	/**
	 * Fire events. Regenerate fields derived from the filtered graph.
	 */
	private void flushUpdate() {

		if (DEBUG) {
			System.out.println("[TrackMateModel] #flushUpdate().");
			System.out.println("[TrackMateModel] #flushUpdate(): Event cache is :" + eventCache);
		}

		/* We recompute tracks only if some edges have been added or removed,
		 * and if some spots have been removed (equivalent to remove edges). We do
		 * NOT recompute tracks if spots have been added: they will not result in
		 * new tracks made of single spots.	 */
		int nEdgesToSignal = trackGraphModel.edgesAdded.size() + trackGraphModel.edgesRemoved.size();
		if (nEdgesToSignal + spotsRemoved.size() > 0) {
			trackGraphModel.computeTracksFromGraph();
		}

		// Deal with new or moved spots: we need to update their features.
		int nSpotsToUpdate = spotsAdded.size() + spotsMoved.size() + spotsUpdated.size();
		if (nSpotsToUpdate > 0) {
			ArrayList<Spot> spotsToUpdate = new ArrayList<Spot>(nSpotsToUpdate);
			spotsToUpdate.addAll(spotsAdded);
			spotsToUpdate.addAll(spotsMoved);
			spotsToUpdate.addAll(spotsUpdated);
			updateFeatures(spotsToUpdate);
		}

		// Initialize event
		TrackMateModelChangeEvent event = new TrackMateModelChangeEvent(this, TrackMateModelChangeEvent.MODEL_MODIFIED);

		// Configure it with spots to signal.
		int nSpotsToSignal = nSpotsToUpdate + spotsRemoved.size();
		if (nSpotsToSignal > 0) {
			ArrayList<Spot> spotsToSignal = new ArrayList<Spot>(nSpotsToSignal);
			spotsToSignal.addAll(spotsAdded);
			spotsToSignal.addAll(spotsRemoved);
			spotsToSignal.addAll(spotsMoved);
			spotsToSignal.addAll(spotsUpdated);
			ArrayList<Integer> spotsFlag = new ArrayList<Integer>(nSpotsToSignal);
			for (int i = 0; i < spotsAdded.size(); i++)
				spotsFlag.add(TrackMateModelChangeEvent.FLAG_SPOT_ADDED);
			for (int i = 0; i < spotsRemoved.size(); i++)
				spotsFlag.add(TrackMateModelChangeEvent.FLAG_SPOT_REMOVED);
			for (int i = 0; i < spotsMoved.size(); i++)
				spotsFlag.add(TrackMateModelChangeEvent.FLAG_SPOT_FRAME_CHANGED);
			for (int i = 0; i < spotsUpdated.size(); i++)
				spotsFlag.add(TrackMateModelChangeEvent.FLAG_SPOT_MODIFIED);

			event.setSpots(spotsToSignal);
			event.setSpotFlags(spotsFlag);
		}


		// Configure it with edges to signal.
		if (nEdgesToSignal > 0) {
			ArrayList<DefaultWeightedEdge> edgesToSignal = new ArrayList<DefaultWeightedEdge>(nEdgesToSignal);
			edgesToSignal.addAll(trackGraphModel.edgesAdded);
			edgesToSignal.addAll(trackGraphModel.edgesRemoved);
			ArrayList<Integer> edgesFlag = new ArrayList<Integer>(nEdgesToSignal);
			for (int i = 0; i < trackGraphModel.edgesAdded.size(); i++)
				edgesFlag.add(TrackMateModelChangeEvent.FLAG_EDGE_ADDED);
			for (int i = 0; i < trackGraphModel.edgesRemoved.size(); i++)
				edgesFlag.add(TrackMateModelChangeEvent.FLAG_EDGE_REMOVED);

			event.setEdges(edgesToSignal);
			event.setEdgeFlags(edgesFlag);
		}

		try {
			if (nEdgesToSignal + nSpotsToSignal > 0) {
				if (DEBUG) {
					System.out.println("[TrackMateModel] #flushUpdate(): firing model modified event.");
				}
				for (final TrackMateModelChangeListener listener : modelChangeListeners) {
					listener.modelChanged(event);
				}
			}

			// Fire events stored in the event cache
			for (int eventID : eventCache) {
				if (DEBUG) {
					System.out.println("[TrackMateModel] #flushUpdate(): firing event with ID "	+ eventID);
				}
				TrackMateModelChangeEvent cachedEvent = new TrackMateModelChangeEvent(this, eventID);
				for (final TrackMateModelChangeListener listener : modelChangeListeners) {
					listener.modelChanged(cachedEvent);
				}
			}

		} finally {
			spotsAdded.clear();
			spotsRemoved.clear();
			spotsMoved.clear();
			spotsUpdated.clear();
			trackGraphModel.edgesAdded.clear();
			trackGraphModel.edgesRemoved.clear();
			eventCache.clear();
		}

	}



}
